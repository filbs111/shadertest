<!DOCTYPE html>
<meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>test scene</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 20px;
		color: white;
		text-align: center;
	}
	
	#info a:link {
				color: white;
	}
		
	#info a:visited {
		color: white;
	}
</style>

<script type="text/javascript" src="lib/dat.gui.min.js"></script>
<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>


<script id="simpletex-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	
	void main(void) {
		gl_FragColor = texture2D(uSampler, vTextureCoord);
	}
</script>

<script id="sumchanstex-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	
	void main(void) {
		vec4 texSample = texture2D(uSampler, vTextureCoord);
		float total = dot(vec4(vec3(1.0),0.0), texSample);
		gl_FragColor = vec4(vec3(total), 1.0);
	}
</script>

<script id="fixedweights-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSamplerLinear;
	uniform sampler2D uSamplerSquare;
	uniform sampler2D uSamplerCross;
	
	uniform vec4 uLinearWeights;
	uniform vec4 uSquareWeights;
	uniform vec4 uCrossWeights;
	uniform vec4 uColorTint;	//should just be 0/1 for "correct" radiosity. better approximation of intermediate 
								//albedos might be acheived by raising textures to a power.

	void main(void) {
		vec4 texSampleLinear = texture2D(uSamplerLinear, vTextureCoord);
		vec4 texSampleSquare = texture2D(uSamplerSquare, vTextureCoord);
		vec4 texSampleCross = texture2D(uSamplerCross, vTextureCoord);

		float total = dot(uLinearWeights, texSampleLinear) + dot(uSquareWeights, texSampleSquare) + dot(uCrossWeights, texSampleCross);
		gl_FragColor = uColorTint * vec4(vec3(pow(total,0.455)), 1.0);
	}
</script>

<script id="simple-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;
	varying vec2 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	
	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTextureCoord = aTextureCoord;
	}
</script>



<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="res/sundial/sundial.obj.json.min"></script>

<script type="text/javascript">

var shaderPrograms={};

var chanWeights = {
	'omni': [0,0,0, 1,1,1],
	'+x': [1,0,0, 0,-.25,-.25],
		//want this light to be ((x+1)^2 ) /4
		// => (x*x + 2x + 1) /4
		// linear x component is light (x+1)/2
		//	(2*lin.x - 1) = x
		// sub in 
		//	(x*x + 2*(2*lin.x - 1) + 1) /4
		//	(x*x)/4 - iso/4 + lin.x
		//	iso = x*x + y*y + z*z
		//=> total is... lin.x - (y*y + z*z)/4

		// square x component is light x*x
		//to get a strong light that goes from 0 to 1 as x goes from -1 to 1,
		// take the average of these values
		//float total = texSampleLinear.x - 0.25*texSampleSquare.y - 0.25*texSampleSquare.z;

	'+y': [0,1,0, -.25,0,-.25],
	'+z': [0,0,1, -.25,-.25,0],

	'-x': [-1,0,0, 1,.75,.75],
		// want this light to be ((x-1)^2 ) /4
		//	=> (x*x - 2x + 1)/4
		// sub in
		//	(x*x - 2*(2*lin.x - 1) + 1) /4
		// (x*x)/4 + 3*iso/4 - lin.x
		//=> total is...  
		//float total = -texSampleLinear.x + texSampleSquare.x + 0.75*texSampleSquare.y + 0.75*texSampleSquare.z;
	'-y': [0,-1,0, .75,1,.75],
	'-z': [0,0,-1, .75,.75,1],

	'+x even': [1,0,0, 0,0,0],
		//want this light to be ((x+1) ) /2
		//float total = texSampleLinear.x;

	'+x weak': [1,0,0, 0,.25,.25],
		//want this light to iso - (-x) - here the dark part of the sky is sharper than the light part
		//float total = texSampleLinear.x + 0.25*texSampleSquare.y + 0.25*texSampleSquare.z;

	'+x fake':[1,0,0, -.2,-.2,-.2],
		//make a fake strong light using just linear/omni. resulting light from some part of sky will be negative, but should only 
		//affect contrived situations eg bottom of well below negative sky.
		//float total = texSampleLinear.x - 0.2* (texSampleSquare.x + texSampleSquare.y + texSampleSquare.z);

	'custom':null

	//custom logic?
	//'+x': [1,0,0, 0,-.25,-.25],
	//'-x':[-1,0,0, 1,.75,.75],
	//	, ...
	// omni lighting is (0,0,0, )
	// for a unit vector (vx,vy,cz), w is sky direction	
	//	want this light to be ((v.w+1)^2 ) /4
	// ie ((x*vx + y*vx + z*vz  +1 )^2 ) / 4
	// =  .25*( x*x *(vx*vx) + y*y *(vy*vy) z*z *(vz*vz))    + .25* ( 2*( vx*(2*lin.x - 1) + ... ) + 1) 
		// 2nd part here is
	// .25* ( 4 (v dot lin) - omni(2 (vx + vy + vz) + 1))
	// so 
	// [ vx, vy, vz , .25-.5*(vx+vy+vz)+.25*(vx*vx), ]	//or something like this. matches +/- x result. sign?
	//	then add in cross terms...

	//calculate this in more sensible way? 
	// simple gradient light in x direction is xlinear *2 - omni
	//simple gradient in general direction 
	// is 2*(xlinear, ylinear, zlinear)*lightDirection - omni*((1,1,1).lightDirection)

	// ((x+1)/2)^2 = x*x/4 + x/2 + 1/4
	//  parabolic light in some direction is avg(simple gradient , avg(simple square light, omni))
	// 
	// simple square light in some xy direction? 
	// guess xdirection^2 * xx component + ydirection^2 * yy component  + xdirection*ydirection * xycomponent
	// but really square light in (vx,vy) ? 
	// (vx, vy) ^2  = vx*vx + vy*vy + 2*(vx*vy)
	// and vx*vy light is encoded as x*y + 0.5
	// so to get back out x*y, subtract 0.5*omni
	// => for diagonal square light want 0.5*xxchan + 0.5*yychan + xychan - 0.5*omni
	//	=> xychan - 0.5*zzchan
	// for general square light? 

	//
	//	half simple gradient in general direction 
	//									(xlinear, ylinear, zlinear)*lightDirection - .5*omni*((1,1,1).lightDirection)
	//	quarter simple square light
	//									.25* (xdirection^2 * xx component + ydirection^2 * yy component  + xdirection*ydirection * xycomponent)
	//	quarter omni
	//									.25*omni

	// => totals
	//	=>light in xy plane = 
	// (where totaldir = (1,1,1).lightDirection = vx+vy+vz )
	// [ vx, vy, 0 , .25*vx*vx-0.5*totaldir+.25 , .25*vy*vy-0.5*totaldir+.25, -0.5*totaldir+.25,  0, 0, vx*vy ]
	// simplfy by totaldirb = .25 - (.5,.5,.5).lightDirection
		//add totaldirb something for cross terms (vx*vy...)
	//  [ vx, vy, 0 , .25*vx*vx+totaldirb , .25*vy*vy+totaldirb, totaldirb,  0, 0, vx*vy ]
		//TODO add nonzero z...

}
var colorTints={
	"white":[1,1,1],
	"red":[1,0,0],
	"green":[0,1,0],
	"blue":[0,0,1],
	"cyan":[0,1,1],
	"magenta":[1,0,1],
	"yellow":[1,1,0]
}

function initShaders(){	
	shaderPrograms.simple = loadShader( "simple-vs", "simpletex-fs",{
		attributes:["aVertexPosition","aTextureCoord"],
		uniforms:["uPMatrix","uMVMatrix","uSampler"]
	});
	shaderPrograms.sumchans = loadShader( "simple-vs", "sumchanstex-fs",{
		attributes:["aVertexPosition","aTextureCoord"],
		uniforms:["uPMatrix","uMVMatrix","uSampler"]
	});
	shaderPrograms.fixedweights = loadShader( "simple-vs", "fixedweights-fs",{
		attributes:["aVertexPosition","aTextureCoord"],
		uniforms:["uPMatrix","uMVMatrix","uSamplerLinear","uSamplerSquare","uSamplerCross","uLinearWeights","uSquareWeights","uCrossWeights","uColorTint"]
	});
	
}

var mvMatrix = mat4.create();
var pMatrix = mat4.create();

var sundialBuffers={};

function initBuffers(){
	
	//console.log(bunnyData);
	
	var sundialObject = loadBlenderExport(sundialData);
	delete sundialObject.normals;	//because current shader doesn't use
	loadBufferData(sundialBuffers, sundialObject);
	
	function bufferArrayData(buffer, arr, size){
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
		buffer.itemSize = size;
		buffer.numItems = arr.length / size;
	}
	
	function loadBufferData(bufferObj, sourceData){
		bufferObj.vertexPositionBuffer = gl.createBuffer();
		bufferArrayData(bufferObj.vertexPositionBuffer, sourceData.vertices, 3);
			
		if (sourceData.uvcoords){
			bufferObj.vertexTextureCoordBuffer= gl.createBuffer();
			bufferArrayData(bufferObj.vertexTextureCoordBuffer, sourceData.uvcoords, 2);
		}
		
		if (sourceData.normals){
			bufferObj.vertexNormalBuffer= gl.createBuffer();
			bufferArrayData(bufferObj.vertexNormalBuffer, sourceData.normals, 3);
		}
		
		bufferObj.vertexIndexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sourceData.indices), gl.STATIC_DRAW);
		bufferObj.vertexIndexBuffer.itemSize = 3;
		bufferObj.vertexIndexBuffer.numItems = sourceData.indices.length;
	}
	
	function loadBlenderExport(meshToLoad){
		return {
			vertices: meshToLoad.vertices,
			normals: meshToLoad.normals,
			uvcoords: meshToLoad.texturecoords?meshToLoad.texturecoords[0]:false,
			indices: [].concat.apply([],meshToLoad.faces)	//trick from https://www.youtube.com/watch?v=sM9n73-HiNA t~ 28:30
		}	
	};
	
}


//possibly calling glviewport slows things down.
var setGlViewportIfNecessary = (function(){
	var savedx=-1;
	var savedy=-1;
	var saveda=-1;
	var savedb=-1;
	return function(a,b,x,y){
		if (x!=savedx || y!=savedy || a!=saveda || b!=savedb){
			gl.viewport(a, b, x, y);
			saveda=a;
			savedb=b;
			savedx=x;
			savedy=y;
		}
	}
})();

var camParams = {near:1, far:1000};

function drawScene(frameTime){
	resizecanvas();

	requestAnimationFrame(drawScene);
	stats.end();
	stats.begin();
	
	//draw the scene straight to the screen
	mat4.perspective(45, gl.viewportWidth/ gl.viewportHeight, camParams.near, camParams.far, pMatrix); 
	
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	setGlViewportIfNecessary(0, 0, gl.viewportWidth, gl.viewportHeight);
	drawWorldScene(frameTime, 0);
}

var playerCamera=mat4.create();
mat4.identity(playerCamera);	//default??
mat4.translate(playerCamera,[0,-5,-25]);

function drawWorldScene(frameTime) {		
	var objToDraw = sundialBuffers;
	//var texToUse = textures[guiParams.texToDisplay];

	mat4.set(playerCamera, mvMatrix)
	
	mat4.rotateX(mvMatrix,-Math.PI/2);
	/*
	mat4.rotateZ(mvMatrix,frameTime/1000);
	mat4.rotateY(mvMatrix,frameTime/10000);
	*/
	
	var activeProg=shaderPrograms.fixedweights;
	gl.useProgram(activeProg);
	
	var cWeights = chanWeights[guiParams.lightType];
	var crossWeights = [0,0,0];

	if (cWeights == null){
		var ang = guiParams.customLightAng;
		var rads = ang*Math.PI/180;
		var xDir = Math.sin(rads);
		var yDir = Math.cos(rads);

		var totalDirB = .25 - .5*(xDir + yDir) + .25*xDir*yDir ;
		cWeights = [xDir, yDir, 0,  .25*xDir*xDir + totalDirB, .25*yDir*yDir + totalDirB, totalDirB];
		//cWeights = [0,0,0,0,0,0];
		crossWeights = [0, 0, -.5*xDir*yDir];
	}

	//console.log(cWeights);
	gl.uniform4f(activeProg.uniforms.uLinearWeights, cWeights[0],cWeights[1],cWeights[2],0);
	gl.uniform4f(activeProg.uniforms.uSquareWeights, cWeights[3],cWeights[4],cWeights[5],0);
	gl.uniform4f(activeProg.uniforms.uCrossWeights, crossWeights[0],crossWeights[1],crossWeights[2],0);

	var tint = colorTints[guiParams.tint];
	gl.uniform4f(activeProg.uniforms.uColorTint, tint[0],tint[1],tint[2],1);

	gl.enableVertexAttribArray(1);
	
	//TODO draw sky.
	//could use same shader as use to draw lit object, using texture maps, but more efficient to calculate in shader.
	
	mat4.rotateZ(mvMatrix,turnAng);
	mat4.rotateX(mvMatrix,pitchAng);

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, textures.linear);
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, textures.squared);
	gl.activeTexture(gl.TEXTURE2);
	gl.bindTexture(gl.TEXTURE_2D, textures.cross);
	drawObjectFromBuffers(objToDraw, activeProg);
}


function drawObjectFromBuffers(bufferObj, shaderProg){
	prepBuffersForDrawing(bufferObj, shaderProg);
	drawObjectFromPreppedBuffers(bufferObj, shaderProg);
}
function prepBuffersForDrawing(bufferObj, shaderProg){
	gl.enable(gl.CULL_FACE);
	gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProg.attributes.aVertexPosition, bufferObj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	if (bufferObj.vertexNormalBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexNormalBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aVertexNormal, bufferObj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	}
	
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
	
	if (bufferObj.vertexTextureCoordBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aTextureCoord, bufferObj.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
		//gl.activeTexture(gl.TEXTURE0);
		//gl.uniform1i(shaderProg.uniforms.uSampler, 0);
		gl.uniform1i(shaderProg.uniforms.uSamplerLinear, 0);
		gl.uniform1i(shaderProg.uniforms.uSamplerSquare, 1);
		gl.uniform1i(shaderProg.uniforms.uSamplerCross, 2);
	}
	gl.uniformMatrix4fv(shaderProg.uniforms.uPMatrix, false, pMatrix);
}
function drawObjectFromPreppedBuffers(bufferObj, shaderProg){
	gl.uniformMatrix4fv(shaderProg.uniforms.uMVMatrix, false, mvMatrix);
	gl.drawElements(gl.TRIANGLES, bufferObj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}

function initTexture(textureKey, src) {
	var texture = gl.createTexture();
	texture.image = new Image();
	texture.image.onload = function() {
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		
		gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
		//gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);	//default
		
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	texture.image.src = src;
	textures[textureKey] = texture;
}

var guiParams={
	lightType:'+x',
	tint:"white",
	customLightAng:0
	};

var textures={};

var turnAng=Math.PI/2;
var pitchAng=0;

function init(){
	
	stats = new Stats();
	stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
	document.body.appendChild( stats.dom );
	
	gui = new dat.GUI();
	gui.add(guiParams, 'lightType', Object.keys(chanWeights));
	gui.add(guiParams, 'tint', Object.keys(colorTints));
	gui.add(guiParams, 'customLightAng',0,360,15);

	canvas = document.getElementById("mycanvas");

	window.addEventListener("keydown",function(evt){
		console.log("key pressed : " + evt.keyCode);
		var willPreventDefault=true;
		var angleStep=Math.PI/32;
		switch (evt.keyCode){
			case 39:
				turnAng-=angleStep;
				break;
			case 37:
				turnAng+=angleStep;
				break;
			case 38:
				pitchAng+=angleStep;
				break;
			case 40:
				pitchAng-=angleStep;
				break;
			default:
				willPreventDefault=false;
				break;
		}
		if (willPreventDefault){evt.preventDefault()};
	});
	
	initGL();
	
	initShaders();
	
	initTexture('linear', "res/sundial/linear_terms_bake1.png");
	initTexture('squared', "res/sundial/square_terms_bake1.png");
	initTexture('cross', "res/sundial/cross_terms_bake1.png");
	
	initBuffers();
	gl.clearColor(0.5, 1.0, 1.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.CULL_FACE);
	gl.cullFace(gl.BACK);
	
	requestAnimationFrame(drawScene);
}

</script>



</head>



<body onload="init()">
<div id="info">Gradient skylighting shader test 2<a href="https://github.com/filbs111/shadertest" target="_blank">https://github.com/filbs111/shadertest</a></div>
		

<canvas id="mycanvas" width="0" height="0">CANVAS TO GO HERE</canvas>


</body>


</html>