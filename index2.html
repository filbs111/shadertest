<!DOCTYPE html>
<meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>test scene</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 20px;
		color: white;
		text-align: center;
	}
	
	#info a:link {
				color: white;
	}
		
	#info a:visited {
		color: white;
	}
</style>

<script type="text/javascript" src="lib/dat.gui.min.js"></script>
<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>


<script id="simpletex-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	
	void main(void) {
		gl_FragColor = texture2D(uSampler, vTextureCoord);
	}
</script>

<script id="sumchanstex-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	
	void main(void) {
		vec4 texSample = texture2D(uSampler, vTextureCoord);
		float total = dot(vec4(vec3(1.0),0.0), texSample);
		gl_FragColor = vec4(vec3(total), 1.0);
	}
</script>

<script id="xpositive-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSamplerLinear;
	uniform sampler2D uSamplerSquare;
	
	void main(void) {
		vec4 texSampleLinear = texture2D(uSamplerLinear, vTextureCoord);
		vec4 texSampleSquare = texture2D(uSamplerSquare, vTextureCoord);

		//want this light to be ((x+1)^2 ) /4
		// => (x*x + 2x + 1) /4
		// linear x component is light (x+1)/2
		//	(2*lin.x - 1) = x
		// sub in 
		//	(x*x + 2*(2*lin.x - 1) + 1) /4
		//	(x*x)/4 - iso/4 + lin.x
		//	iso = x*x + y*y + z*z
		//=> total is... lin.x - (y*y + z*z)/4

		// square x component is light x*x
		//to get a strong light that goes from 0 to 1 as x goes from -1 to 1,
		// take the average of these values

		float total = texSampleLinear.x - 0.25*texSampleSquare.y - 0.25*texSampleSquare.z;

		gl_FragColor = vec4(vec3(total), 1.0);
	}
</script>

<script id="xnegative-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSamplerLinear;
	uniform sampler2D uSamplerSquare;
	
	void main(void) {
		vec4 texSampleLinear = texture2D(uSamplerLinear, vTextureCoord);
		vec4 texSampleSquare = texture2D(uSamplerSquare, vTextureCoord);

		// want this light to be ((x-1)^2 ) /4
		//	=> (x*x - 2x + 1)/4
		// sub in
		//	(x*x - 2*(2*lin.x - 1) + 1) /4
		// (x*x)/4 + 3*iso/4 - lin.x
		//=> total is...  

		float total = -texSampleLinear.x + texSampleSquare.x + 0.75*texSampleSquare.y + 0.75*texSampleSquare.z;

		gl_FragColor = vec4(vec3(total), 1.0);
	}
</script>


<script id="simple-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;
	varying vec2 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	
	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTextureCoord = aTextureCoord;
	}
</script>



<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="res/sundial/sundial.obj.json.min"></script>

<script type="text/javascript">

var shaderPrograms={};

function initShaders(){	
	shaderPrograms.simple = loadShader( "simple-vs", "simpletex-fs",{
		attributes:["aVertexPosition","aTextureCoord"],
		uniforms:["uPMatrix","uMVMatrix","uSampler"]
	});
	shaderPrograms.sumchans = loadShader( "simple-vs", "sumchanstex-fs",{
		attributes:["aVertexPosition","aTextureCoord"],
		uniforms:["uPMatrix","uMVMatrix","uSampler"]
	});
	shaderPrograms["+x"] = loadShader( "simple-vs", "xpositive-fs",{
		attributes:["aVertexPosition","aTextureCoord"],
		uniforms:["uPMatrix","uMVMatrix","uSamplerLinear","uSamplerSquare"]
	});
	shaderPrograms["-x"] = loadShader( "simple-vs", "xnegative-fs",{
		attributes:["aVertexPosition","aTextureCoord"],
		uniforms:["uPMatrix","uMVMatrix","uSamplerLinear","uSamplerSquare"]
	});
}

var mvMatrix = mat4.create();
var pMatrix = mat4.create();

var sundialBuffers={};

function initBuffers(){
	
	//console.log(bunnyData);
	
	var sundialObject = loadBlenderExport(sundialData);
	delete sundialObject.normals;	//because current shader doesn't use
	loadBufferData(sundialBuffers, sundialObject);
	
	function bufferArrayData(buffer, arr, size){
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
		buffer.itemSize = size;
		buffer.numItems = arr.length / size;
	}
	
	function loadBufferData(bufferObj, sourceData){
		bufferObj.vertexPositionBuffer = gl.createBuffer();
		bufferArrayData(bufferObj.vertexPositionBuffer, sourceData.vertices, 3);
			
		if (sourceData.uvcoords){
			bufferObj.vertexTextureCoordBuffer= gl.createBuffer();
			bufferArrayData(bufferObj.vertexTextureCoordBuffer, sourceData.uvcoords, 2);
		}
		
		if (sourceData.normals){
			bufferObj.vertexNormalBuffer= gl.createBuffer();
			bufferArrayData(bufferObj.vertexNormalBuffer, sourceData.normals, 3);
		}
		
		bufferObj.vertexIndexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sourceData.indices), gl.STATIC_DRAW);
		bufferObj.vertexIndexBuffer.itemSize = 3;
		bufferObj.vertexIndexBuffer.numItems = sourceData.indices.length;
	}
	
	function loadBlenderExport(meshToLoad){
		return {
			vertices: meshToLoad.vertices,
			normals: meshToLoad.normals,
			uvcoords: meshToLoad.texturecoords?meshToLoad.texturecoords[0]:false,
			indices: [].concat.apply([],meshToLoad.faces)	//trick from https://www.youtube.com/watch?v=sM9n73-HiNA t~ 28:30
		}	
	};
	
}


//possibly calling glviewport slows things down.
var setGlViewportIfNecessary = (function(){
	var savedx=-1;
	var savedy=-1;
	var saveda=-1;
	var savedb=-1;
	return function(a,b,x,y){
		if (x!=savedx || y!=savedy || a!=saveda || b!=savedb){
			gl.viewport(a, b, x, y);
			saveda=a;
			savedb=b;
			savedx=x;
			savedy=y;
		}
	}
})();

var camParams = {near:1, far:1000};

function drawScene(frameTime){
	resizecanvas();

	requestAnimationFrame(drawScene);
	stats.end();
	stats.begin();
	
	//draw the scene straight to the screen
	mat4.perspective(45, gl.viewportWidth/ gl.viewportHeight, camParams.near, camParams.far, pMatrix); 
	
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	setGlViewportIfNecessary(0, 0, gl.viewportWidth, gl.viewportHeight);
	drawWorldScene(frameTime, 0);
}

var playerCamera=mat4.create();
mat4.identity(playerCamera);	//default??
mat4.translate(playerCamera,[0,-5,-25]);

function drawWorldScene(frameTime) {		
	var objToDraw = sundialBuffers;
	//var texToUse = textures[guiParams.texToDisplay];

	mat4.set(playerCamera, mvMatrix)
	
	mat4.rotateX(mvMatrix,-Math.PI/2);
	/*
	mat4.rotateZ(mvMatrix,frameTime/1000);
	mat4.rotateY(mvMatrix,frameTime/10000);
	*/
	
	var activeProg=shaderPrograms[guiParams.lightType];
	gl.useProgram(activeProg);
	
	gl.enableVertexAttribArray(1);
	
	//TODO draw sky.
	//could use same shader as use to draw lit object, using texture maps, but more efficient to calculate in shader.
	
	mat4.rotateZ(mvMatrix,turnAng);
	mat4.rotateX(mvMatrix,pitchAng);

	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, textures.linear);
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, textures.squared);
	drawObjectFromBuffers(objToDraw, activeProg);
}


function drawObjectFromBuffers(bufferObj, shaderProg){
	prepBuffersForDrawing(bufferObj, shaderProg);
	drawObjectFromPreppedBuffers(bufferObj, shaderProg);
}
function prepBuffersForDrawing(bufferObj, shaderProg){
	gl.enable(gl.CULL_FACE);
	gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProg.attributes.aVertexPosition, bufferObj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	if (bufferObj.vertexNormalBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexNormalBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aVertexNormal, bufferObj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	}
	
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
	
	if (bufferObj.vertexTextureCoordBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aTextureCoord, bufferObj.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
		//gl.activeTexture(gl.TEXTURE0);
		//gl.uniform1i(shaderProg.uniforms.uSampler, 0);
		gl.uniform1i(shaderProg.uniforms.uSamplerLinear, 0);
		gl.uniform1i(shaderProg.uniforms.uSamplerSquare, 1);
	}
	gl.uniformMatrix4fv(shaderProg.uniforms.uPMatrix, false, pMatrix);
}
function drawObjectFromPreppedBuffers(bufferObj, shaderProg){
	gl.uniformMatrix4fv(shaderProg.uniforms.uMVMatrix, false, mvMatrix);
	gl.drawElements(gl.TRIANGLES, bufferObj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}

function initTexture(textureKey, src) {
	var texture = gl.createTexture();
	texture.image = new Image();
	texture.image.onload = function() {
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		
		gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
		//gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);	//default
		
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	texture.image.src = src;
	textures[textureKey] = texture;
}

var guiParams={
	lightType:'+x'
	};

var textures={};

var turnAng=Math.PI/2;
var pitchAng=0;

function init(){
	
	stats = new Stats();
	stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
	document.body.appendChild( stats.dom );
	
	gui = new dat.GUI();
	gui.add(guiParams, 'lightType', ['+x','-x']);
	
	canvas = document.getElementById("mycanvas");

	window.addEventListener("keydown",function(evt){
		console.log("key pressed : " + evt.keyCode);
		var willPreventDefault=true;
		var angleStep=Math.PI/32;
		switch (evt.keyCode){
			case 39:
				turnAng-=angleStep;
				break;
			case 37:
				turnAng+=angleStep;
				break;
			case 38:
				pitchAng+=angleStep;
				break;
			case 40:
				pitchAng-=angleStep;
				break;
			default:
				willPreventDefault=false;
				break;
		}
		if (willPreventDefault){evt.preventDefault()};
	});
	
	initGL();
	
	initShaders();
	
	initTexture('linear', "res/sundial/linear_terms_bake1.png");
	initTexture('squared', "res/sundial/square_terms_bake1.png");
	initTexture('cross', "res/sundial/cross_terms_bake1.png");
	
	initBuffers();
	gl.clearColor(0.5, 1.0, 1.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.CULL_FACE);
	gl.cullFace(gl.BACK);
	
	requestAnimationFrame(drawScene);
}

</script>



</head>



<body onload="init()">
<div id="info">Gradient skylighting shader test 2<a href="https://github.com/filbs111/shadertest" target="_blank">https://github.com/filbs111/shadertest</a></div>
		

<canvas id="mycanvas" width="0" height="0">CANVAS TO GO HERE</canvas>


</body>


</html>